# Secrets Operator

This tool follows the Kubernetes Operator Pattern, and is used to synchronize Secrets.

# This tool is still in early development, and experimental. Everything is subject to change. Use at your own risk.

## Motivation

Consider the following use case: You have an operator that is going to deploy a database, and create a Secret with the username and password to access it. Next, you use a Helm chart to deploy an application that will consume that Secret to connect to the database, but, horror of horrors, that Helm chart wants different keys to be in that Secret than the database operator will produce! Even worse, if that Helm chart is particularly brain-dead, it may require that secret to even have a specific name! Tragedy! You'll have to manually copy that secret and correct it for the Helm chart to accept it.

Not to worry! Simply create a DerivedSecret resource to automatically generate a Secret that meets the picky Helm chart's demands by synchronizing it with whatever Secret is generated by the operator!

Some likewise brain-dead operators will only let you create their custom resources in the same namespace as the operator themselves, irritating if you'd like to consume the Secrets generated by those custom resources in applications in other namespaces. Just as before, a DerivedSecret will fix you right up, as you can target the generated secret to the correct namespace.

## Custom Resources

This operator provides the `DerivedSecret` resource. This represents a desired Secret that is based on one or more other Secrets and/or ConfigMaps, called "references". You can simply copy fields from references, or you can use Golang templates (with Sprig functions) to create entirely new values. Values that should be set once and only once (e.g. randomly generated) can be set to not overwrite upon update.

```yaml
apiVersion: secrets.meln5674.github.com/v1alpha1
kind: DerivedSecret
metadata:
  name: my-derived-secret # By default, the generated secret will have the same name
spec:
  # This is the list of ConfigMaps and Secrets you can reference
  references:
  - name: myReference # Name can be anything, but valid go identifies are recommended for reasons below
    configMapRef:
      name: my-config-map
    # Or
    secretRef:
      name: my-secret
  # If you just want to copy a set of fields, you can use the prefab section
  prefab:
    # Copy every field from every reference, failing on duplicate keys
    copyAll: true
    # Or
    # Copy every field, except the ones listed
    copyExcluding:
    - name: myReference
      # Omit to exclude every key in the reference, or specify a subset
      keys: [not,these,keys]
    # Or
    # Copy just the fields listed
    copyIncluding:
    - name: myReference
      # Omit to include every key in the reference, or specify a subset
      keys: [just,these,keys]
  # Or, if you need fine-grained control
  stringData:
    # Encode literal data
    my-literal-key:
      literal: 'SHH! It's a secret!'
    # Or, apply a template to keys from references
    my-template-key:
      template: {{ .References.myReference.key }}
  # Also works with binary (Base64-encoded) data
  data:
    # We can safely use random functions from sprig with the 'overwrite: false' field
    my-random-secret:
      overwrite: false
      template: '{{ randBytes 32 | b64enc }}'
    # Binary literals are also supported
    another-literal-key:
      literal: 'VGhpcyBpcyBhIHNlY3JldCwgd2hhdCBhcmUgeW91IGRvaW5nIGxvb2tpbmcgYXQgaXQ/Cg=='

  # If you need a different secret name, here's how to set it
  secretName: some-other-secret-name 

  # You can also target different namespaces
  secretNamespace: some-other-namespace
  # However, this raises security concerns. In this case, you will need to provide the name of a
  # ServiceAccount in the same namespace as the DerivedSecret to perform this action,
  # just to make sure you aren't doing something you're not allowed to
  # Make sure that the operator has permissions to impersonate this ServiceAccount
  serviceAccoutName: secrets-creator
```

## Building

Requires:
* Go 1.17
* Make
* Docker

```bash
make build docker-build
```

## Installing

Requires:
* Make
* Kubectl
* Kustomize
* A working Kubernetes cluster

```bash
# Uses kustomize
make install deploy
```

## Running Tests

Requires:
* Go 1.17
* Make
* Kubectl
* Kustomize
* Krew (Installs Kuttl)
* KinD

```bash
make test
# Requires krew, kubectl, 
make kuttl-tests
